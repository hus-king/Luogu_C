# STL算法

- `find(begin, end, value)`：在区间 `[begin, end)` 中查找值为 `value` 的元素，返回指向该元素的迭代器，如果未找到则返回 `end`。

- `sort(begin, end)`：对区间 `[begin, end)` 内的元素进行升序排序。

- `reverse(begin, end)`：将区间 `[begin, end)` 内的元素顺序反转。

- `unique(begin, end)`：移除区间 `[begin, end)` 内的连续重复元素，返回新的逻辑结束迭代器。

- `random_shuffle(begin, end)`：随机打乱区间 `[begin, end)` 内的元素顺序。

- `stable_sort(begin, end)`：对区间 `[begin, end)` 内的元素进行稳定排序，保持相等元素的相对顺序。

- `nth_element(begin, end, n)`：将区间 `[begin, end)` 内的第 `n` 个最小元素放到正确的位置，其他元素无序排列。nth_element(v.begin(), v.begin() + n, v.end(), cmp), 其中左边均小于第n个元素，右边均大于第n个元素。

- `binary_search(begin, end, value)`：在已排序的区间 `[begin, end)` 中查找值为 `value` 的元素，返回布尔值表示是否找到。

- `merge(v1.begin(), v1.end(), v2.begin(), v2.end() ,back_inserter(v3))`：将两个已排序的区间 `[begin1, end1)` 和 `[begin2, end2)` 合并到容器 `v3` 中。

- `inplace_merge(v.begin(), v.begin() + middle, v.end())`：将容器 `v` 中的两个已排序子区间 `[begin, middle)` 和 `[middle, end)` 合并为一个已排序区间。

- `lower_bound(begin, end, value)`：在已排序的区间 `[begin, end)` 中查找第一个不小于 `value` 的位置，返回指向该位置的迭代器。

- `upper_bound(begin, end, value)`：在已排序的区间 `[begin, end)` 中查找第一个大于 `value` 的位置，返回指向该位置的迭代器。

- `next_permutation(begin, end)`：生成区间 `[begin, end)` 内的下一个字典序排列，返回布尔值表示是否存在下一个排列。

- `prev_permutation(begin, end)`：生成区间 `[begin, end)` 内的上一个字典序排列，返回布尔值表示是否存在上一个排列。

- `partial_sum(src.begin(), src.end(), back_inserter(dst))`：计算容器 `src` 的前缀和，并将结果存储到容器 `dst` 中。