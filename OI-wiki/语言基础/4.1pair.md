# pair

## 1 初始化

`std::pair<type1, type2>` ： 用于存储一对值的容器，类型可以不同。

### 构造函数

```cpp
// 1. 默认构造函数，创建一个空pair p0
pair<int, double> p0;
// 2. 使用指定的值初始化pair p1
pair<int, double> p1(10, 3.14);
// 3. 使用另一个pair p2初始化pair p3
pair<int, double> p2(20, 2.71);
pair<int, double> p3(p2);
// 4. 使用make_pair函数创建一个pair p4
auto p4 = make_pair(30, 1.61);
```

## 2 基础操作

### 2.1 访问元素

1. `first` ： 访问pair的第一个元素
2. `second` ： 访问pair的第二个元素

```cpp
pair<int, double> p(10, 3.14);
cout << p.first << " " << p.second << endl; // 输出: 10 3.14
```

### 2.2 比较操作

`pair`已经预先定义了所有的比较运算符,包括`==`, `!=`, `<`, `<=`, `>`, `>=`。比较时会先比较`first`元素, 如果相等则比较`second`元素。

```cpp
pair<int, double> p1(10, 3.14);
pair<int, double> p2(10, 2.71);
if (p1 > p2) {
    cout << "p1 is greater than p2" << endl; // 输出: p1 is greater than p2
}   
```

由于`pair`定义了STL中常用的`<`与`==`运算符, 因此可以直接用于`map`等关联容器的键类型。

```cpp
map<pair<int, int>, string> mp;
mp[make_pair(1, 2)] = "one-two";
mp[make_pair(2, 3)] = "two-three"; 
cout << mp[make_pair(1, 2)] << endl; // 输出: one-two
```

### 2.3 赋值与交换

1. 赋值运算符 `=` ： 将一个pair赋值给另一个pair
2. `swap(other)` ： 交换两个pair的内容

## 3 应用示例

### 3.1 离散化

```cpp
// a为原始数据
pair<int, int> a[MAXN];
// ai为离散化后的数据
int ai[MAXN];
for (int i = 0; i < n; i++) {
  // first为原始数据的值，second为原始数据的位置
  scanf("%d", &a[i].first);
  a[i].second = i;
}
// 排序
sort(a, a + n);
for (int i = 0; i < n; i++) {
  // 将该值的排名赋给该值原本所在的位置
  ai[a[i].second] = i;
}
```

### 3.2 Dijkstra

在`Dijkstra`算法的堆优化中，可以使用`pair``与`priority_queue`维护节点，将节点当前到起点的距离作为第一个变量，将节点编号作为第二个变量。
```cpp
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > pq;
pq.push(make_pair(0, start)); // 起点距离为0
while (!pq.empty()) {
    auto [dist, u] = pq.top();
    pq.pop();
    // 处理节点u
}
```
