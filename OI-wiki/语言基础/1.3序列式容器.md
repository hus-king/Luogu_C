# 序列式容器

## 容器对比总结

| 特性 | vector | deque | list | array |
|------|--------|-------|------|-------|
| **底层实现** | 动态数组 | 分段数组 | 双向链表 | 固定数组 |
| **随机访问** | O(1) | O(1) | O(n) | O(1) |
| **头部插入/删除** | O(n) | O(1) | O(1) | 不支持 |
| **尾部插入/删除** | O(1) 均摊 | O(1) | O(1) | 不支持 |
| **中间插入/删除** | O(n) | O(n) | O(1) | 不支持 |
| **内存连续** | 是 | 否 | 否 | 是 |
| **大小可变** | 是 | 是 | 是 | 否 |
| **适用场景** | 频繁随机访问<br>尾部操作多 | 两端操作多 | 频繁插入删除<br>不需随机访问 | 固定大小<br>编译期确定 |

## vector

`std::vector<type, allocator>` ：后段可高效增加元素的的顺序表

### 构造函数

```cpp
// 1. 创建空vector; 常数复杂度
vector<int> v0;
// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度
v0.reserve(3);
// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度
vector<int> v1(3);
// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度
vector<int> v2(3, 2);
// 4. 创建一个初始空间为3的vector，其元素的默认值是1，
// 并且使用v2的空间配置器; 线性复杂度
vector<int> v3(3, 1, v2.get_allocator());
// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度
vector<int> v4(v2);
// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度
vector<int> v5(v4.begin() + 1, v4.begin() + 3);
// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11
vector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);
```

### 元素访问

1. `at(index)` ：返回对指定位置元素的引用，并且进行范围检查，若越界则抛出`out_of_range`异常

2. `operator[index]` ：返回对指定位置元素的引用，不进行范围检查

3. `front()` ：返回对第一个元素的引用

4. `back()` ：返回对最后一个元素的引用

5. `data()` ：返回指向数组第一个元素的指针

```cpp
vector<int> v = {1, 2, 3, 4, 5};
cout << v.at(0) << " " << v[1] << " " << v.front() << " " << v.back() << endl;
// 输出: 1 2 1 5
int* p = v.data();  // p 指向 v 的第一个元素
cout << *p << endl;  // 输出: 1
```

### 元素增删及修改
1. `clear()` ： 清空容器内容
2. `insert(pos, value)` ： 在迭代器 pos 所指位置前插入元素 value，返回指向新插入元素的迭代器
3. `erase(pos)` ： 删除迭代器 pos 所指位置的元素，返回指向被删除元素下一个位置的迭代器
4. `push_back(value)` ： 在容器末尾添加元素 value
5. `pop_back()` ： 删除容器末尾的元素
6. `swap(other)` ： 交换两个容器的内容

## array

`std::array<type, size>` ： 固定大小的顺序表

## deque
`std::deque<type, allocator>` ： 双端队列，支持在两端高效插入和删除元素

### 构造函数

```cpp
// 1. 定义一个int类型的空双端队列 v0
deque<int> v0;
// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度
deque<int> v1(10);
// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度
deque<int> v2(10, 1);
// 4. 复制已有的双端队列 v1; 线性复杂度
deque<int> v3(v1);
// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度
deque<int> v4(v2.begin(), v2.begin() + 3);
// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11
deque<int> v5(std::move(v2));
```

### 元素访问

1. `at(index)` ：返回对指定位置元素的引用，并且进行范围检查，若越界则抛出`out_of_range`异常

2. `operator[index]` ：返回对指定位置元素的引用，不进行范围检查

3. `front()` ：返回对第一个元素的引用

4. `back()` ：返回对最后一个元素的引用

### 元素增删及修改

与 vector 类似，但支持在两端高效插入和删除元素：
1. `push_front(value)` ： 在容器前端添加元素 value
2. `pop_front()` ： 删除容器前端的元素

## list

`std::list<type, allocator>` ： 双向链表，能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。

### 构造函数

```cpp
// 1. 定义一个int类型的空链表 l0
list<int> l0;
// 2. 定义一个int类型的链表 l1，并设置初始大小为10; 线性复杂度
list<int> l1(10);
// 3. 定义一个int类型的链表 l2，并初始化为10个1; 线性复杂度
list<int> l2(10, 1);
// 4. 复制已有的链表 l1; 线性复杂度
list<int> l3(l1);
// 5. 创建一个l2的拷贝list l4，其内容是l4[0]至l4[2]; 线性复杂度
list<int> l4(l2.begin(), l2.begin() + 3);
// 6. 移动l2到新创建的list l5，不发生拷贝; 常数复杂度; 需要 C++11
list<int> l5(std::move(l2));
```

### 元素访问

由于是链表,不支持随机访问，只能通过迭代器进行遍历和访问。

1. `front()` ：返回对第一个元素的引用
2. `back()` ：返回对最后一个元素的引用

