# 多重背包问题

多重背包是 0-1 背包问题的一种变体，区别在于：**每种物品有数量限制 $k_i$**（即第 $i$ 种物品最多可选 $k_i$ 件），而非仅能选 0 或 1 件。

---

## 🧠 基本思路（朴素解法）

将「第 $i$ 种物品最多选 $k_i$ 次」等价转化为「有 $k_i$ 个相同的独立物品」，从而退化为 0-1 背包问题。

- 状态定义：  
  $f_{i,j}$ 表示前 $i$ 种物品、容量为 $j$ 时能获得的最大价值。

- 状态转移方程：  
  $$
  f_{i,j} = \max_{0 \le k \le k_i \atop k \cdot w_i \le j}
  \left( f_{i-1,\,j - k \cdot w_i} + k \cdot v_i \right)
  $$

- 时间复杂度：  
  $O\left(W \cdot \sum_{i=1}^{n} k_i\right)$，其中 $W$ 为背包容量，$n$ 为物品种类数。

---

## 💻 朴素实现（三维退化为二维滚动数组）

```cpp
// dp[j]：容量为 j 时能获得的最大价值
vector<int> dp(W + 1, 0);

for (int i = 1; i <= n; i++) {
    for (int weight = W; weight >= w[i]; weight--) {  // 必须倒序！防止重复选取
        for (int k = 1; k <= cnt[i] && k * w[i] <= weight; k++) {
            dp[weight] = max(dp[weight], dp[weight - k * w[i]] + k * v[i]);
        }
    }
}
```

## ⚡ 优化方案：二进制分组优化（Binary Grouping）

### 🔍 动机

朴素做法对每个物品重复枚举 $k_i$ 次，存在大量等价选择（如选第1+2个 vs 第2+3个）。  
**瓶颈**：$O\left(\sum k_i\right)$ 过高 → 改为 $O\left(\sum \log k_i\right)$。

核心思想：**用少量“组合物品”无损覆盖 $0$ 到 $k_i$ 的所有选取数量**。

---

### 🛠️ 分组原理

将 $k_i$ 拆分为若干个 $2$ 的幂次之和（类似二进制表示）：

- 令 $t = \lfloor \log_2(k_i + 1) \rfloor$；
- 拆分为：  
  $$
  1,\ 2,\ 4,\ \dots,\ 2^{t-1},\ r = k_i - (2^t - 1)
  $$
  其中 $r \ge 0$，且 $r < 2^{t-1}$（若 $r = 0$ 则无需最后一项）。

✅ 正确性保证：任意 $x \in [0, k_i]$ 都可唯一表示为上述拆分项的子集和（二进制组合性质）。

#### 拆分示例

| $k_i$ | 拆分方案                | 说明                          |
|--------|-------------------------|-------------------------------|
| 6      | $1 + 2 + 3$            | $2^0, 2^1, r=3$              |
| 8      | $1 + 2 + 4 + 1$        | $2^0,2^1,2^2,r=1$（注意：$8 = 2^3$，但按 $k_i+1=9$ 算 $\lfloor\log_2 9\rfloor=3$）|
| 18     | $1 + 2 + 4 + 8 + 3$    | $2^0\sim2^3$, $r = 18-15 = 3$ |
| 31     | $1 + 2 + 4 + 8 + 16$   | $31 = 2^5 - 1$，无余项        |

> 📌 注：代码中常用 `while (k > c)` 拆分，自动处理余项。

---

### ⏱️ 复杂度分析

- 每种物品拆成 $O(\log k_i)$ 个新物品；
- 总物品数 → $O\left(\sum_{i=1}^n \log k_i\right)$；
- 套用 0-1 背包 → **时间复杂度：$O\left(W \cdot \sum_{i=1}^n \log k_i\right)$**。

---

### 💻 代码实现（C++）

```cpp
struct Item { int w, v; };
vector<Item> items; // 拆分后的物品列表

for (int i = 1; i <= n; i++) {
    int w_i = weight[i], v_i = value[i], k_i = cnt[i];
    int c = 1;
    while (k_i > c) {
        items.emplace_back(c * w_i, c * v_i);
        k_i -= c;
        c <<= 1; // c *= 2
    }
    if (k_i > 0) {
        items.emplace_back(k_i * w_i, k_i * v_i);
    }
}

// 接下来做标准 0-1 背包
vector<int> dp(W + 1, 0);
for (auto &item : items) {
    for (int j = W; j >= item.w; j--) {
        dp[j] = max(dp[j], dp[j - item.w] + item.v);
    }
}
```

> ✅ 优势：代码简洁、常数小、易实现，适用于绝大多数场景（$k_i \le 10^5$ 量级完全够用）。
