# DAG 上的动态规划（DAG DP）

## 📌 什么是 DAG DP？

- **DAG**：Directed Acyclic Graph（有向无环图）  
- **核心思想**：  
  将具有「偏序依赖关系」的实际问题建模为 DAG，转化为 **最长路 / 最短路** 问题求解。  
  → 由于无环，可按拓扑序递推，天然满足 DP 的无后效性与最优子结构。

> ✅ 典型场景：任务调度、嵌套结构（盒子套盒子、矩形嵌套）、堆叠限制（本题）、状态转移图等。

---

## 🧪 经典例题：UVa 437 巴比伦塔（The Tower of Babylon）

### 📖 题意简述

- 给定 $n \le 30$ 种砖块，每种砖块是一个长方体，三边长为 $(x, y, z)$；
- 每种砖块**数量无限**，但**每块只能用一次**（即塔中每个位置放一块砖）；
- 每块砖可**任选一条边作为高**，其余两条作为底面（长、宽）；
- **堆叠规则**：上方砖块的底面**长和宽均严格小于**下方砖块的底面（允许旋转底面）；
- **目标**：求能搭出的塔的**最大高度**。

---

## 🛠️ 建模过程：从问题到 DAG

### 第一步：处理「一个砖块三种放法」

每块砖 $(x, y, z)$ 可以有 3 种有效摆放方式（高不同，底面为剩下两数的无序对）：

| 摆放编号 $r$ | 高 $h$ | 底面尺寸（无序） |
|--------------|--------|------------------|
| 0            | $x$    | $\{y, z\}$       |
| 1            | $y$    | $\{x, z\}$       |
| 2            | $z$    | $\{x, y\}$       |

⚠️ 注意：
- 为统一比较，规定底面存储为 `(min, max)`，即：  
  $\{a, b\} \to (\min(a,b), \max(a,b))$

→ 将每种原始砖块拆成 **3 个虚拟节点**，共 $3n$ 个节点。

---

### 第二步：构建 DAG 边

- 节点 $u$（对应某砖块某摆放方式）可放在节点 $v$ **之上**，当且仅当：  
  $$
  \text{u 的底面长} < \text{v 的底面长} \quad \text{且} \quad \text{u 的底面对角边} < \text{v 的底面对角边}
  $$
  即：  
  $$
  u.\text{base}_1 < v.\text{base}_1 \quad \&\& \quad u.\text{base}_2 < v.\text{base}_2
  $$

- 添加有向边：  
  $v \to u$，**边权 = $u$ 的高度 $h_u$**  
  （含义：在 $v$ 之上放 $u$，总高度增加 $h_u$）

> 🔔 为什么是 `v → u`？  
> 因为 DP 状态定义为「以某砖块为底」的最大高度，我们从底层向上扩展，故箭头指向更上方的砖块。

---

### 第三步：引入「大地」起点（可选）

- 虚拟节点 `ground`，底面为 $(\infty, \infty)$，高度为 0；
- 从 `ground` 向**所有砖块节点**连边，边权 = 该砖块高度；
- 作用：统一入口，避免多重初始化。

> 💡 实际编码中可省略 `ground`，直接初始化所有砖块节点的 DP 值 = 自身高。

---

## 📐 状态设计与转移方程

### 状态定义

设：
- $d[i][r]$：以**第 $i$ 块砖**、采用**第 $r$ 种摆放方式**作为**塔底**时，能搭出的**最大高度**。

> 等价于：从该节点出发，在 DAG 上走一条路径所能获得的**最大路径权值和**（含自身）。

### 状态转移

$$
d[i][r] = h_{i,r} + \max_{\substack{j, r' \\ \text{砖 } j \text{ 可放在 } (i,r) \text{ 上}}} \left\{ d[j][r'] \right\}
$$

即：当前砖块高度 + 所有能放在它**上面**的砖块所能构成的最大高度。

> 🔄 注意方向！  
> 「能放在 $(i,r)$ **上**」 ⇔ 在 DAG 中存在边 $(i,r) \to (j,r')$  
> 但在递推时，我们通常反向思考：对每个 $(j,r')$，更新所有能作为它**下方**的 $(i,r)$ —— 更推荐用 **记忆化搜索** 避免显式拓扑排序。

---

## 💻 实现建议：记忆化搜索（自顶向下）

```cpp
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
constexpr int MAXN = 30 + 5;
constexpr int MAXV = 500 + 5;
int d[MAXN][3];
int x[MAXN], y[MAXN], z[MAXN];

int babylon_sub(int c, int rot, int n) {
  if (d[c][rot] != -1) {
    return d[c][rot];
  }
  d[c][rot] = 0;
  int base1, base2;
  if (rot == 0) {  // 处理三个方向
    base1 = x[c];
    base2 = y[c];
  }
  if (rot == 1) {
    base1 = y[c];
    base2 = z[c];
  }
  if (rot == 2) {
    base1 = x[c];
    base2 = z[c];
  }
  for (int i = 0; i < n; i++) {  // 根据不同条件，分别调用不同的递归
    if ((x[i] < base1 && y[i] < base2) || (y[i] < base1 && x[i] < base2))
      d[c][rot] = max(d[c][rot], babylon_sub(i, 0, n) + z[i]);
    if ((y[i] < base1 && z[i] < base2) || (z[i] < base1 && y[i] < base2))
      d[c][rot] = max(d[c][rot], babylon_sub(i, 1, n) + x[i]);
    if ((x[i] < base1 && z[i] < base2) || (z[i] < base1 && x[i] < base2))
      d[c][rot] = max(d[c][rot], babylon_sub(i, 2, n) + y[i]);
  }
  return d[c][rot];
}

int babylon(int n) {
  for (int i = 0; i < n; i++) {
    d[i][0] = -1;
    d[i][1] = -1;
    d[i][2] = -1;
  }
  int r = 0;
  for (int i = 0; i < n; i++) {  // 三种建法
    r = max(r, babylon_sub(i, 0, n) + z[i]);
    r = max(r, babylon_sub(i, 1, n) + x[i]);
    r = max(r, babylon_sub(i, 2, n) + y[i]);
  }
  return r;
}

int main() {
  int t = 0;
  while (true) {  // 死循环求答案
    int n;
    cin >> n;
    if (n == 0) break;  // 没有砖头了就停止
    t++;
    for (int i = 0; i < n; i++) {
      cin >> x[i] >> y[i] >> z[i];
    }
    cout << "Case " << t << ":"
         << " maximum height = " << babylon(n);  // 递归
    cout << endl;
  }
  return 0;
}
```