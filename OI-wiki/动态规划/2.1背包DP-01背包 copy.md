# 01背包
>有 $N$ 件物品和一个容量为 $M$ 的背包。第 $i$ 件物品的重量是 $W_i$，价值是 $D_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

$dp[l]$表示背包容量为$l$时，能获得的最大价值。 

状态转移：`dp[l] = max(dp[l], dp[l - w[i]] + v[i])`

- `dp[l]`：不选第 `i` 件物品 → 价值不变。
- `dp[l - w[i]] + v[i]`：选第 `i` 件物品 → 剩余容量 `l - w[i]` 能获得的最大价值 + 当前物品价值。
- 取两者最大值 → 更新当前容量下的最优解。

```cpp
// 使用 vector 存储物品重量和价值，下标从 0 开始
vector<int> w(n), v(n);
for (int i = 0; i < n; ++i) {
    cin >> w[i] >> v[i];
}

// dp[l] 表示容量为 l 的背包能获得的最大价值
vector<int> dp(W + 1, 0);  // 初始化为 0，大小为 W+1（容量 0~W）

// 动态规划：0-1 背包
for (int i = 0; i < n; ++i) {                // 遍历每件物品
    for (int l = W; l >= w[i]; --l) {        // 倒序遍历容量
        dp[l] = max(dp[l], dp[l - w[i]] + v[i]);
    }
}

cout << dp[W] << endl;  // 输出容量为 W 时的最大价值
```