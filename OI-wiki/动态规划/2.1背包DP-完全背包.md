# 完全背包
>有 $N$ 种物品和一个容量为 $M$ 的背包。第 $i$ 种物品的重量是 $W_i$，价值是 $D_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

$dp[l]$表示背包容量为$l$时，能获得的最大价值。 

状态转移：`dp[l] = max(dp[l], dp[l - w[i]] + v[i])`

- `dp[l]`：不选第 `i` 件物品 → 价值不变。
- `dp[l - w[i]] + v[i]`：选第 `i` 件物品 → 剩余容量 `l - w[i]` 能获得的最大价值 + 当前物品价值。
- 取两者最大值 → 更新当前容量下的最优解。

```cpp
vector<int> w(n), v(n);
for (int i = 0; i < n; ++i) {
    cin >> w[i] >> v[i];
}

// dp[l] = 容量为 l 时能获得的最大价值
vector<int> dp(W + 1, 0);

// 完全背包：每种物品可选无限次
for (int i = 0; i < n; ++i) {               // 遍历每种物品
    for (int l = w[i]; l <= W; ++l) {       // ⬅️ 正序遍历容量
        dp[l] = max(dp[l], dp[l - w[i]] + v[i]);
    }
}

cout << dp[W] << endl;
```