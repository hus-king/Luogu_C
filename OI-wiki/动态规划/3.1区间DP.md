# 区间动态规划（Interval DP）

## 📌 定义

区间 DP 是 **线性动态规划的扩展**，适用于「将一个区间内的元素通过两两合并逐步缩成一个整体」的问题。

- **状态设计**：  
  设 $f(i, j)$ 表示将下标区间 $[i, j]$ 内的所有元素合并所能获得的**最优价值**（最大或最小）。

- **状态转移方程（通用形式）**：  
  $$
  f(i, j) = \max_{i \le k < j} \left\{ f(i, k) + f(k+1, j) + \text{cost}(i, j, k) \right\}
  $$
  其中 $\text{cost}(i, j, k)$ 是将 $[i,k]$ 与 $[k+1,j]$ 合并所产生的额外代价（或收益）。

---

## 🔑 核心性质

| 特性 | 说明 |
|------|------|
| **可合并性** | 问题能被划分为若干子区间，且整体最优解由子区间最优解「合并」而来 |
| **无后效性** | 合并后的价值仅取决于当前区间 $[i,j]$ 和分割点 $k$，与合并顺序无关（满足最优子结构） |
| **阶段划分** | 按区间长度 `len = j - i + 1` 从小到大递推，确保子问题先被计算 |

> ✅ 典型场景：石子合并、矩阵链乘、最优二叉搜索树、回文串构造等。

---

## 🧪 经典例题：『NOI1995』石子合并

### 📖 题意简述

- $n$ 堆石子围成**环形**，第 $i$ 堆有 $a_i$ 颗；
- 每次合并**相邻两堆**，得分为合并后新堆的石子总数；
- 共合并 $n-1$ 次，最终只剩一堆；
- **目标**：最大化总得分。

---

### 🔁 问题转化：环 → 链

环形结构难以直接 DP，常用两种处理方式：

| 方法 | 思路 | 时间复杂度 |
|------|------|------------|
| **枚举断点** | 枚举环的断开位置（共 $n$ 种），每种转为链做一次 DP | $O(n^4)$ |
| **破环成链** ✅ | 将数组复制一倍：$a_1, a_2, \dots, a_n, a_1, a_2, \dots, a_n$，在长度为 $2n$ 的链上 DP，答案取所有长度为 $n$ 的区间最优值 | $O(n^3)$ |

> 推荐使用 **破环成链** 法，效率更高。

---

### 🧮 状态设计与转移（链上版本）

- **前缀和优化**：设 $sum[i] = a_1 + a_2 + \dots + a_i$，则区间 $[i,j]$ 石子总数为 $sum[j] - sum[i-1]$。

- **状态定义**：  
  $f(i, j)$：将区间 $[i, j]$ 合并为一堆所能获得的**最大得分**。

- **转移方程**：  
  $$
  f(i, j) = 
  \begin{cases}
  0, & i = j \\
  \max\limits_{i \le k < j} \left\{ f(i, k) + f(k+1, j) + (sum[j] - sum[i-1]) \right\}, & i < j
  \end{cases}
  $$

> 📝 合并代价 = 当前区间石子总数（因为每次合并得到的分等于新堆大小，最终每颗石子被累加的次数 = 它参与合并的次数）。

---

### ⚙️ DP 执行顺序

必须按**区间长度 `len` 升序**递推：

```cpp
for (int len = 2; len <= n; len++) {          // 区间长度从 2 到 n
    for (int i = 1; i + len - 1 <= 2 * n; i++) {  // 起点 i，终点 j = i + len - 1
        int j = i + len - 1;
        f[i][j] = 0;
        for (int k = i; k < j; k++) {         // 枚举分割点
            f[i][j] = max(f[i][j], 
                          f[i][k] + f[k+1][j] + sum[j] - sum[i-1]);
        }
    }
}
```